# 数组中重复的数字

## 题目描述
在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是重复的2或者3。

## 解析
**解法一**：双重循环，时间复杂度O(n^2)，空间复杂度O(1);

**解法二**：两遍哈希表，时间复杂度O(n),空间复杂度O(n);

**解法三**：一遍哈希表,时间复杂度O(n),空间复杂度O(n);

以上三种解法类似于leetcode_1.

**解法四**：两遍散列表，题目中的原数组元素个数为length，且所有元素值都小于length，因此可以定义长度为length的新数组，新数组的下标为原数组的元素值，新数组的值为其下标出现的次数，这样扫描一次原数组就可以统计出所有元素出现的次数；再扫描一次新数组就可以找到一个出现次数大于1的值。时间复杂度O(n),空间复杂度O(n);（该解法类似解法二）

**解法五**：一遍散列表，时间复杂度O(n),空间复杂度O(n)（该解法类似解法三）

**解法六**：排序，先把输入的数组排序，再判断相邻位置是否存在相同数字，如果存在，对duplication赋值返回，否则继续比较

**解法七**：利用特性，数组里的所有数字都在0到n-1的范围内，且数组长度为n，如果这个数组中没有重复的数字，那么当数组排序之后数字i将出现在下标为i的位置。利用这个特性，把数字和下标不同的数换到属于它的位置，当交换的两个数相同的时候，说明有重复数字，记录并返回！

具体做法：从头到尾扫描数组中的每个数字，当扫描到下标为i的数字时，首先比较这个数字（比如m）是否等于i。如果相等，则继续扫描下一个数字；如果不等，将它和第m个数字进行交换。如果它和第m个数字相等，就找到了一个重复的数字；如果它和第m个数字不相等，就把它和第m个数字交换，即m找到了属于它的位置。接下来重复这个比较、交换的过程，直到发现一个重复的数字。

<font color="red">注意</font>：该种解法不能保证返回的是第一个重复的数字，但满足本题题意。

**解法七时间复杂度分析**

因为每个数字最多只要交换两次就能找到属于它的位置（比如，把2跟5交换，只要交换一次2就在正确的位置，而5还需要再交换一次就能跑到正确的位置，即整个过程中，2只需要交换一次，5需要交换2次）。所以总的时间复杂度为O(n)。

换个角度理解，每次交换都会将一个数放在正确的位置上，一共只有n个数和n个位置，最多交换n-1次。所以总时间复杂度是O(n)。

**解法八**：使用Lis只保存key也可以实现，时间复杂度O(n)，空间复杂度O(n)。

**解法九**：使用Set，时间复杂度O(n)，空间复杂度O(n)

**解法九**：此解法来自牛客上的BoTinker，充分利用的题目的信息。为了解决n可能溢出的问题，我对他的解法进行了修改，将+length变成了-length。思路：题目里写了数组里数字的范围保证在0~n-1之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数-n，之后再遇到相同的数时，会发现对应位上的数已经小于0了，那么直接返回这个数即可。<font color="red">注意</font>：该解法的前提是可以修改原数组中的元素。

以{1,3,3,2}为例，当i=0时，numbers[0]=1>0,numbers[1]=3>0,因此numbers[1]=numbers[1]-4=-1;当i=1时，numbers[1]=-1<0，numbers[3]=2>0,因此numbers[3]=numbers[3]-4=-2;当i=2时，numbers[2]=3>0,numbers[3]<0,因此3重复。